// AUTO GENERATED. DO NOT EDIT.
//
#pragma once
#include <cstdint>
#include <mutex>
#include <shared_mutex>

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

#include "gendb/bytes.h"
{% if indices|length > 0 %}
#include "gendb/index.h"
#include "gendb/iterator.h"
{% endif %}

#include "absl/status/status.h"
#include "gendb/layered_storage.h"
#include "gendb/message_base.h"
#include "gendb/message_patch.h"

{% if namespace %} namespace {{ namespace }} {
{% endif %}

// Forward declarations.
class Guard;
class ScopedWrite;

enum CollectionId {
{% for coll in collections %}
  {{ coll.enum_name }} = {{ loop.index0 }},
{% endfor %}
};

// Collection keys getters.
{% for coll in collections %}
{% if coll.pk_type == 'String' %}
inline BytesConstView To{{ coll.type }}Key(std::string_view {{ coll.pk_name }}) {
    return {reinterpret_cast<const uint8_t*>({{ coll.pk_name }}.data()), {{ coll.pk_name }}.size()};
}
{% else %}
inline std::array<uint8_t, sizeof({{ coll.pk_cpp_type }})> To{{ coll.type }}Key({{ coll.pk_const_ref_type }}  {{ coll.pk_name}}) {
  std::array<uint8_t, sizeof({{ coll.pk_cpp_type }})> key_raw;
  WriteScalarRaw(key_raw.data(), {{ coll.pk_name }});
  return key_raw;
}
{% endif %}
inline BytesConstView To{{ coll.type }}Key({{ coll.type }} {{ coll.type_snake_case }}) {
  return {{ coll.type_snake_case }}.FieldRaw({{ coll.type }}::{{ coll.pk_enum }});
}
{% endfor %}

{% if indices|length > 0 %}
struct Indices {
{% for idx in indices %}
  using {{ idx.name_pascal_case }}IndexType = {{ idx.index_class }};
  {{ idx.name_pascal_case }}IndexType {{ idx.name }};
{% endfor %}

  void MergeTempIndices(Indices&& temp_indices) {
{% for idx in indices %}
    {{ idx.name }}.MergeTempIndex(std::move(temp_indices.{{ idx.name }}));
{% endfor %}
  }
};
{% endif %}

class Db {
 public:
  Guard SharedLock() const;
  ScopedWrite CreateWriter();

 private:
  friend class Guard;
  friend class ScopedWrite;

  std::mutex _writer_mutex;
  mutable std::shared_mutex _reader_mutex;
  Storage _storage;
{% if indices|length > 0 %}
  Indices _indices;
{% endif %}
};

class Guard {
 public:
{% for coll in collections %}
  absl::Status Get{{ coll.type }}({{ coll.pk_const_ref_type }} {{coll.pk_name}}, {{ coll.type }}& {{ coll.type_snake_case }}) const;
{% endfor %}
{% for idx in indices %}
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Range({{ idx.key_cpp_type }} min_{{ idx.field}}, {{ idx.key_cpp_type }} max_{{ idx.field }}) const;
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Equal({{ idx.key_cpp_type }} {{ idx.field }}) const;
{% endfor %}
  ~Guard() = default;
 private:
  friend class Db;
  Guard(const Db& db, std::shared_lock<std::shared_mutex> lock)
      : _db(db),
        _lock(std::move(lock)),
        _layered_storage(const_cast<Storage&>(_db._storage), /*temp_storage_ptr=*/nullptr) {}

 private:
  const Db& _db;
  std::shared_lock<std::shared_mutex> _lock;
  const gendb::LayeredStorage _layered_storage;
};

class ScopedWrite {
 public:
{% for coll in collections %}
  absl::Status Get{{ coll.type }}({{ coll.pk_const_ref_type }} {{coll.pk_name}}, {{ coll.type }}& {{ coll.type_snake_case }}) const;
  absl::Status Put{{ coll.type }}({{ coll.pk_const_ref_type }} {{coll.pk_name}}, std::vector<uint8_t> {{ coll.type_snake_case }});
  absl::Status Update{{ coll.type }}({{ coll.pk_const_ref_type }} {{coll.pk_name}}, const MessagePatch& update);
{% endfor %}
{% for idx in indices %}
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Range({{ idx.key_cpp_type }} min_{{ idx.field}}, {{ idx.key_cpp_type }} max_{{ idx.field }}) const;
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Equal({{ idx.key_cpp_type }} {{ idx.field }}) const;
{% endfor %}

  void Commit();
  ~ScopedWrite() = default;

 private:
  friend class Db;
  ScopedWrite(Db& db, std::unique_lock<std::mutex> lock)
      : _db(const_cast<Db&>(db)),
        _lock(std::move(lock)),
        _layered_storage(_db._storage, &_temp_storage) {}

  // Index update helpers
{% for idx in indices %}
  void MaybeUpdate{{ idx.name_pascal_case }}Index(std::array<uint8_t, sizeof({{ idx.value_cpp_type }})> key,
                                    gendb::BytesConstView {{ idx.type|lower }}_buffer,
                                    const MessagePatch* update);
{% endfor %}

 private:
  Db& _db;
  std::unique_lock<std::mutex> _lock;
  gendb::Storage _temp_storage;
{% if indices|length > 0 %}
  Indices _temp_indices;
{% endif %}
  gendb::LayeredStorage _layered_storage;
};

{% if namespace %}
} // namespace {{ namespace }}
{% endif %}
