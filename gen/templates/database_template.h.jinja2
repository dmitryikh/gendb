// AUTO GENERATED. DO NOT EDIT.
//
#pragma once
#include <cstdint>
#include <mutex>
#include <shared_mutex>

{% for include in includes %}
#include "{{ include }}"
{% endfor %}

#include "gendb/bytes.h"
{% if indices|length > 0 %}
#include "gendb/index.h"
#include "gendb/iterator.h"
{% endif %}

#include "absl/status/status.h"
#include "gendb/layered_storage.h"
#include "gendb/message_patch.h"
#include "gendb/key_codec.h"

{% if namespace %} namespace {{ namespace }} {
{% endif %}

// Forward declarations.
class Guard;
class ScopedWrite;

enum CollectionId {
{% for coll in collections %}
  {{ coll.enum_name }} = {{ loop.index0 }},
{% endfor %}
};

// Collection keys getters.
{% for coll in collections %}
{% if coll.pk_fields | length > 1 %}
{# multifield primary key #}
struct {{ coll.type | pascalcase }}Key {
{% for pk in coll.pk_fields %}
  {{ pk.const_ref_type }} {{ pk.name }};
{% endfor %}
};

{% if coll.pk_fixed_size > 0 %}
  {% set tuple_type = "std::tuple<" + coll.pk_fields | map(attribute='cpp_type') | join(', ') + ">" %}
inline std::array<uint8_t, {{coll.pk_fixed_size}}> To{{ coll.type | pascalcase }}Key(const {{ coll.type | pascalcase }}Key& key) {
  std::array<uint8_t, {{ coll.pk_fixed_size }}> key_raw;
  internal::key_codec::EncodeTupleToView<{{ tuple_type }}>({{'{'}}{% for pk in coll.pk_fields %}key.{{ pk.name }}{% if not loop.last %}, {% endif %}{% endfor %}{{'}'}}, key_raw);
  return key_raw;
}

inline std::array<uint8_t, {{coll.pk_fixed_size}}> To{{ coll.type | pascalcase }}Key({{ coll.type }} {{ coll.type_snake_case }}) {
  std::array<uint8_t, {{ coll.pk_fixed_size }}> key_raw;
  internal::key_codec::EncodeTupleToView<{{ tuple_type }}>({{'{'}}{% for pk in coll.pk_fields %}{{ coll.type_snake_case }}.{{ pk.name }}(){% if not loop.last %}, {% endif %}{% endfor %}{{'}'}}, key_raw);
  return key_raw;
}
{% else %}
{# multifield primary key with runtime length #}
inline Bytes To{{ coll.type | pascalcase }}Key(const {{ coll.type | pascalcase }}Key& key) {
  return internal::key_codec::EncodeTuple<{{ tuple_type }}>({{'{'}}{% for pk in coll.pk_fields %}key.{{ pk.name }}{% if not loop.last %}, {% endif %}{% endfor %}{{'}'}});
}

inline Bytes To{{ coll.type | pascalcase }}Key({{ coll.type }} {{ coll.type_snake_case }}) {
  return internal::key_codec::EncodeTuple<{{ tuple_type }}>({{'{'}}{% for pk in coll.pk_fields %}{{ coll.type_snake_case }}.{{ pk.name }}(){% if not loop.last %}, {% endif %}{% endfor %}{{'}'}});
}
{% endif %}  {# if coll.pk_fixed_size > 0 #}
{% else %}   {# if coll.pk_fields | length > 1 #}
{% if coll.pk_fixed_size > 0 %}
inline std::array<uint8_t, {{ coll.pk_fixed_size }}> To{{ coll.type | pascalcase }}Key({{ coll.pk_fields[0].const_ref_type }} {{coll.pk_fields[0].name}}) {
  std::array<uint8_t, {{ coll.pk_fixed_size }}> key_raw;
  internal::key_codec::EncodeTupleToView<std::tuple<{{ coll.pk_fields[0].cpp_type }}>>({{'{'}}{{ coll.pk_fields[0].name }}{{'}'}}, key_raw);
  return key_raw;
}

inline std::array<uint8_t, {{ coll.pk_fixed_size }}> To{{coll.type | pascalcase}}Key({{ coll.type }} {{ coll.type_snake_case }}) {
  return To{{ coll.type | pascalcase }}Key({{ coll.type_snake_case }}.{{coll.pk_fields[0].name}}());
}
{% else %} {# if coll.pk_fixed_size > 0 #}
inline Bytes To{{ coll.type | pascalcase }}Key({{ coll.pk_fields[0].const_ref_type }} {{coll.pk_fields[0].name}}) {
  return internal::key_codec::EncodeTuple(std::make_tuple({{ coll.pk_fields[0].name }}));
}

inline Bytes To{{ coll.type | pascalcase }}Key({{ coll.type }} {{ coll.type_snake_case }}) {
  return internal::key_codec::EncodeTuple(std::make_tuple({{ coll.type_snake_case }}.{{ coll.pk_fields[0].name }}()));
}

{% endif %}  {# if coll.pk_fixed_size > 0 #}
{% endif %}  {# if coll.pk_fields | length >  1 #}
{% endfor %}

{% if indices|length > 0 %}
struct Indices {
{% for idx in indices %}
  using {{ idx.name_pascal_case }}IndexType = {{ idx.index_class }};
  {{ idx.name_pascal_case }}IndexType {{ idx.name }};
{% endfor %}

  void MergeTempIndices(Indices&& temp_indices) {
{% for idx in indices %}
    {{ idx.name }}.MergeTempIndex(std::move(temp_indices.{{ idx.name }}));
{% endfor %}
  }
};
{% endif %}

class Db {
 public:
  Guard SharedLock() const;
  ScopedWrite CreateWriter();

 private:
  friend class Guard;
  friend class ScopedWrite;

  std::mutex _writer_mutex;
  mutable std::shared_mutex _reader_mutex;
  Storage _storage;
{% if indices|length > 0 %}
  Indices _indices;
{% endif %}
};

class Guard {
 public:
{% for coll in collections %}
  absl::Status Get{{ coll.type | pascalcase}}({% if coll.pk_fields | length > 1 %}const {{ coll.type | pascalcase }}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{coll.pk_fields[0].name}}{% endif %}, {{coll.type}}& {{coll.type_snake_case}}) const;
{% endfor %}
{% for idx in indices %}
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Range({{ idx.key_cpp_type }} min_{{ idx.field}}, {{ idx.key_cpp_type }} max_{{ idx.field }}) const;
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Equal({{ idx.key_cpp_type }} {{ idx.field }}) const;
{% endfor %}
  ~Guard() = default;
 private:
  friend class Db;
  Guard(const Db& db, std::shared_lock<std::shared_mutex> lock)
      : _db(db),
        _lock(std::move(lock)),
        _layered_storage(const_cast<Storage&>(_db._storage), /*temp_storage_ptr=*/nullptr) {}

 private:
  const Db& _db;
  std::shared_lock<std::shared_mutex> _lock;
  const gendb::LayeredStorage _layered_storage;
};

class ScopedWrite {
 public:
{% for coll in collections %}
  absl::Status Get{{ coll.type | pascalcase}}({% if coll.pk_fields | length > 1 %}const {{ coll.type | pascalcase }}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{coll.pk_fields[0].name}}{% endif %}, {{ coll.type}}& {{ coll.type_snake_case }}) const;
  absl::Status Put{{ coll.type | pascalcase}}({% if coll.pk_fields | length > 1 %}const {{ coll.type | pascalcase }}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{coll.pk_fields[0].name}}{% endif %}, std::vector<uint8_t> {{ coll.type_snake_case }});
  absl::Status Update{{ coll.type | pascalcase}}({% if coll.pk_fields | length > 1 %}const {{ coll.type | pascalcase }}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{coll.pk_fields[0].name}}{% endif %}, const MessagePatch& update);
{% endfor %}
{% for idx in indices %}
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Range({{ idx.key_cpp_type }} min_{{ idx.field}}, {{ idx.key_cpp_type }} max_{{ idx.field }}) const;
  gendb::Iterator<{{ idx.type }}> Get{{ idx.name_pascal_case }}Equal({{ idx.key_cpp_type }} {{ idx.field }}) const;
{% endfor %}

  void Commit();
  ~ScopedWrite() = default;

 private:
  friend class Db;
  ScopedWrite(Db& db, std::unique_lock<std::mutex> lock)
      : _db(const_cast<Db&>(db)),
        _lock(std::move(lock)),
        _layered_storage(_db._storage, &_temp_storage) {}

  // Index update helpers
{% for idx in indices %}
  void MaybeUpdate{{ idx.name_pascal_case }}Index(std::array<uint8_t, sizeof({{ idx.value_cpp_type }})> key,
                                    gendb::BytesConstView {{ idx.type|lower }}_buffer,
                                    const MessagePatch* update);
{% endfor %}

 private:
  Db& _db;
  std::unique_lock<std::mutex> _lock;
  gendb::Storage _temp_storage;
{% if indices|length > 0 %}
  Indices _temp_indices;
{% endif %}
  gendb::LayeredStorage _layered_storage;
};

{% if namespace %}
} // namespace {{ namespace }}
{% endif %}
