// AUTO GENERATED. DO NOT EDIT.
//
#include "{{ generated_source_base_name }}.h"

#include <cstdint>
{% for include in includes %}
#include "{{ include }}"
{% endfor %}
#include "absl/status/status.h"
#include "gendb/status.h"
#include "gendb/bytes.h"
#include "gendb/message_patch.h"
#include "gendb/iterator.h"

{% if indices|length > 0 %}
#include <optional>
#include "gendb/index.h"
{% endif %}


namespace {{ namespace }} {

Guard Db::SharedLock() const {
  return {*this, std::shared_lock<std::shared_mutex>(_reader_mutex)};
}

ScopedWrite Db::CreateWriter() {
  return {*this, std::unique_lock<std::mutex>(_writer_mutex)};
}

{% for coll in collections %}
absl::Status Guard::Get{{coll.type}}(
  {% if coll.pk_fields | length > 1 %}const {{coll.type}}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{ coll.pk_fields[0].name }}{% endif %},
  {{ coll.type }}& {{ coll.type_snake_case }}
) const {
  BytesConstView value;
  RETURN_IF_ERROR(_layered_storage.Get(
    {{ coll.enum_name }},
    {% if coll.pk_fields | length > 1 %}To{{coll.type}}Key(key){% else %}To{{coll.type}}Key({{ coll.pk_fields[0].name }}){% endif %},
    value));
  {{ coll.type_snake_case }} = {{ coll.type }}{value};
  return absl::OkStatus();
}

absl::Status ScopedWrite::Get{{coll.type}}(
  {% if coll.pk_fields | length > 1 %}const {{coll.type}}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{ coll.pk_fields[0].name }}{% endif %},
  {{ coll.type }}& {{ coll.type_snake_case }}
) const {
  BytesConstView value;
  RETURN_IF_ERROR(_layered_storage.Get(
    {{ coll.enum_name }},
    {% if coll.pk_fields | length > 1 %}To{{coll.type}}Key(key){% else %}To{{coll.type}}Key({{ coll.pk_fields[0].name }}){% endif %},
    value));
  {{ coll.type_snake_case }} = {{ coll.type }}{value};
  return absl::OkStatus();
}

absl::Status ScopedWrite::Put{{coll.type}}(
  {% if coll.pk_fields | length > 1 %}const {{coll.type}}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{ coll.pk_fields[0].name }}{% endif %},
  Bytes {{ coll.type_snake_case }}
) {
  auto key_ = {% if coll.pk_fields | length > 1 %}To{{coll.type}}Key(key){% else %}To{{coll.type}}Key({{ coll.pk_fields[0].name }}){% endif %};
  {% for idx in indices %}
  {% if idx.type == coll.type %}
  MaybeUpdate{{ idx.name_pascal_case }}Index(key_, {{ coll.type_snake_case }}, /*update=*/nullptr);
  {% endif %}
  {% endfor %}
  _temp_storage.Put({{ coll.enum_name }}, key_, std::move({{ coll.type_snake_case }}));
  return absl::OkStatus();
}

absl::Status ScopedWrite::Update{{coll.type}}(
  {% if coll.pk_fields | length > 1 %}const {{coll.type}}Key& key{% else %}{{ coll.pk_fields[0].const_ref_type }} {{ coll.pk_fields[0].name }}{% endif %},
  const MessagePatch& update
) {
  Bytes* ptr = nullptr;
  auto key_ = {% if coll.pk_fields | length > 1 %}To{{coll.type}}Key(key){% else %}To{{coll.type}}Key({{ coll.pk_fields[0].name }}){% endif %};
  RETURN_IF_ERROR(_layered_storage.EnsureInTempStorage({{ coll.enum_name }}, key_, &ptr));
  {% for idx in indices %}
  {% if idx.type == coll.type %}
  MaybeUpdate{{ idx.name_pascal_case }}Index(key_, *ptr, &update);
  {% endif %}
  {% endfor %}
  gendb::ApplyPatch<{{ coll.type }}>(update, *ptr);
  return absl::OkStatus();
}
{% endfor %}


{% for idx in indices %}
gendb::Iterator<{{ idx.type }}> Guard::Get{{ idx.name_pascal_case }}Range({{ idx.key_cpp_type }} min_{{ idx.field }}, {{ idx.key_cpp_type }} max_{{ idx.field }}) const {
  return gendb::MakeSecondaryIndexIterator<{{ idx.type }}, Indices::{{ idx.name_pascal_case }}IndexType>(
      _layered_storage, {{ idx.type }}CollId, _db._indices.{{ idx.name }}.lower_bound(min_{{ idx.field }}),
      _db._indices.{{ idx.name }}.lower_bound(max_{{ idx.field }}));
}

gendb::Iterator<{{ idx.type }}> Guard::Get{{ idx.name_pascal_case }}Equal({{ idx.key_cpp_type }} {{ idx.field }}) const {
  return gendb::MakeSecondaryIndexIterator<{{ idx.type }}, Indices::{{ idx.name_pascal_case }}IndexType>(
      _layered_storage, {{ idx.type }}CollId, _db._indices.{{ idx.name }}.lower_bound({{ idx.field }}),
      _db._indices.{{ idx.name }}.upper_bound({{ idx.field }}));
}

gendb::Iterator<{{ idx.type }}> ScopedWrite::Get{{ idx.name_pascal_case }}Range({{ idx.key_cpp_type }} min_{{ idx.field }}, {{ idx.key_cpp_type }} max_{{ idx.field }}) const {
  return gendb::MakeSecondaryIndexIterator<{{ idx.type }}, Indices::{{ idx.name_pascal_case }}IndexType>(
      _layered_storage, {{ idx.type }}CollId, _db._indices.{{ idx.name }}.lower_bound(min_{{ idx.field }}),
      _db._indices.{{ idx.name }}.lower_bound(max_{{ idx.field }}),
      _temp_indices.{{ idx.name }}.lower_bound(min_{{ idx.field }}),
      _temp_indices.{{ idx.name }}.lower_bound(max_{{ idx.field }}));
}

gendb::Iterator<{{ idx.type }}> ScopedWrite::Get{{ idx.name_pascal_case }}Equal({{ idx.key_cpp_type }} {{ idx.field }}) const {
  return gendb::MakeSecondaryIndexIterator<{{ idx.type }}, Indices::{{ idx.name_pascal_case }}IndexType>(
      _layered_storage, {{ idx.type }}CollId, _db._indices.{{ idx.name }}.lower_bound({{ idx.field }}),
      _db._indices.{{ idx.name }}.upper_bound({{ idx.field }}), _temp_indices.{{ idx.name }}.lower_bound({{ idx.field }}),
      _temp_indices.{{ idx.name }}.upper_bound({{ idx.field }}));
}

void ScopedWrite::MaybeUpdate{{ idx.name_pascal_case }}Index(std::array<uint8_t, sizeof({{ idx.value_cpp_type }})> key,
                                               gendb::BytesConstView {{ idx.type_snake_case }}_buffer,
                                               const MessagePatch* update) {
  std::optional<{{ idx.key_cpp_type }}> {{ idx.field }}_before = std::nullopt;
  std::optional<{{ idx.key_cpp_type }}> {{ idx.field }}_after = std::nullopt;
  if (update != nullptr  && !DoModifyField(*update, {{ idx.type }}::{{ idx.field_enum }})) {
    // This is update op which doesn't touch the indexed field.
    return;
  }
  {{ idx.type }} {{ idx.type_snake_case }}{{'{'}}{{ idx.type_snake_case }}_buffer};
  if ({{ idx.type_snake_case }}.has_{{ idx.field }}()) {
    {{ idx.field }}_before = {{ idx.type_snake_case }}.{{ idx.field }}();
  }
  if (update != nullptr) {
    {{ idx.type }} {{ idx.type_snake_case }}_update{update->buffer};
    if ({{ idx.type_snake_case }}_update.has_{{ idx.field }}()) {
      {{ idx.field }}_after = {{ idx.type_snake_case }}_update.{{ idx.field }}();
    }
  }
  if ({{ idx.field }}_before.has_value()) {
    _temp_indices.{{ idx.name }}.Insert({{ idx.field }}_before.value(), key,
                                        /*is_deleted=*/update != nullptr);
  }
  if ({{ idx.field }}_after.has_value()) {
    _temp_indices.{{ idx.name }}.Insert({{ idx.field }}_after.value(), key);
  }
}
{% endfor %}

{% for seq in sequences %}
absl::Status ScopedWrite::Next{{ seq.name|replace('_', ' ')|title|replace(' ', '') }}(uint64_t& next_id) {
  MetadataValue value;
  MetadataValueKey key{.type = MetadataType::kSequence, .id = {{ seq.metadata_id }}};
  auto status = GetMetadataValue(key, value);
  if (status.code() == absl::StatusCode::kNotFound) {
    RETURN_IF_ERROR(PutMetadataValue(key, MetadataValueBuilder().set_int_value(1).Build()));
    next_id = 1;
  } else if (!status.ok()) {
    return status;
  } else {
    int new_next_id = value.int_value() + 1;
    RETURN_IF_ERROR(UpdateMetadataValue(key, MetadataValuePatchBuilder().set_int_value(new_next_id).Build()));
    next_id = new_next_id;
  }
  return absl::OkStatus();
}
{% endfor %}

void ScopedWrite::Commit() {
  std::unique_lock lock(_db._reader_mutex);
  _layered_storage.MergeTempStorage();
{% if indices|length > 0 %}
  _db._indices.MergeTempIndices(std::move(_temp_indices));
{% endif %}
}

}  // namespace {{ namespace }}
