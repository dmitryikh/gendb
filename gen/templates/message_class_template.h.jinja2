
// AUTO GENERATED. DO NOT EDIT.
//
#pragma once
#include <cstdint>
#include <array>
#include <string_view>

#include "gendb/message_base.h"
#include "gendb/message_builder.h"
#include "gendb/bits.h"
#include "gendb/message_patch.h"

// Enum definitions
{% for enum in enums.values() %}
{% if enum.namespace %}namespace {{ enum.namespace.replace('.', '::') }} {
{% endif %}
enum class {{ enum.name }} : {{ enum.underlying_type }} {
  {% for value_name, value in enum.vals %}
  {{ value_name }} = {{ value }},
  {% endfor %}
};
{% if enum.namespace %}
} // namespace {{ enum.namespace.replace('.', '::') }}
{% endif %}
{% endfor %}

// Message classes
{% for table in tables %}
{% if table.namespace %}namespace {{ table.namespace }} {
{% endif %}
// GeneratedClass
class {{ table.name }} : private gendb::MessageBase {
 public:

  enum Field : int {
    {% for field in table.fields %}
    {{ field.name | pascalcase }} = {{ loop.index }},
    {% endfor %}
    MaxFields
  };

  static constexpr std::array<uint32_t, {{ table.K }}> kFixedSizeFields = gendb::MakeConstexprFieldBitmask<{{ table.K }}>({
    {% for field in table.fixed_fields %}
      {{ field.name | pascalcase }},
    {% endfor %}
  });

  {{ table.name }}() = default;
  {{ table.name }}(std::span<const uint8_t> span) : MessageBase(span) {}

  {% for field in table.fields %}
  bool has_{{field.name}}() const { return HasField({{ field.name | pascalcase }}); }
  {% if field.cpp_type == 'std::string' %}
  std::string_view {{field.name}}() const { return ReadStringField({{ field.name | pascalcase }}, ""); }
  {% elif field.field_kind == FieldKind.ENUM %}
  {{ field.cpp_type }} {{field.name}}() const { return static_cast<{{ field.cpp_type }}>(ReadScalarField<{{field.underlying_type}}>({{ field.name | pascalcase }}, {{ field.default }})); }
  {% else %}
  {{ field.cpp_type }} {{field.name}}() const { return ReadScalarField<{{ field.cpp_type }}>({{ field.name | pascalcase }}, {{ field.default }}); }
  {% endif %}
  {% endfor %}


  // MessageBase methods.
  using gendb::MessageBase::FieldCount;
  using gendb::MessageBase::HasField;
  using gendb::MessageBase::GetFieldsMask;
  std::span<const uint8_t> FieldRaw(int field_id) const {
    return gendb::MessageBase::FieldRaw(field_id);
  }

  friend class {{table.name}}Builder;
};

class {{table.name}}Builder : public gendb::MessageBuilder {
 public:
  {{table.name}}Builder() : MessageBuilder() {}
  {{table.name}}Builder({{table.name}}& obj) : MessageBuilder(obj) {}

  {% for field in table.fields %}
  {% if field.cpp_type == 'std::string' %}
  {{table.name}}Builder& set_{{field.name}}(std::string_view value) { AddStringField({{ table.name }}::{{ field.name | pascalcase }}, value); return *this; }
  {% elif field.field_kind == FieldKind.ENUM %}
  {{table.name}}Builder& set_{{field.name}}({{ field.cpp_type }} value) { AddField<{{ field.underlying_type }}>({{ table.name }}::{{ field.name | pascalcase }}, static_cast<{{ field.underlying_type }}>(value)); return *this; }
  {% else %}
  {{table.name}}Builder& set_{{field.name}}({{ field.const_ref_type }} value) { AddField<{{ field.cpp_type }}>({{ table.name }}::{{ field.name | pascalcase }}, value); return *this; }
  {% endif %}
  {% endfor %}

  {% for field in table.fields %}
  {{table.name}}Builder& clear_{{field.name}}() { ClearField({{ table.name }}::{{ field.name | pascalcase }}); return *this; }
  {% endfor %}

  std::vector<uint8_t> Build() { return MessageBuilder::Build(); }
};

class {{table.name}}PatchBuilder {
 public:
  {{table.name}}PatchBuilder() = default;
  // TODO: Add constructor with primary key fields.

  {% for field in table.fields %}
  {{table.name}}PatchBuilder&& set_{{field.name}}({{ field.const_ref_type }} value) && {
    _builder.set_{{field.name}}(value);
    SetFieldBit(modified, {{ table.name }}::{{ field.name | pascalcase }});
    UnsetFieldBit(removed, {{ table.name }}::{{ field.name | pascalcase }});
    return std::move(*this);
  }
  {{table.name}}PatchBuilder&& clear_{{field.name}}() && {
    SetFieldBit(removed, {{ table.name }}::{{ field.name | pascalcase }});
    UnsetFieldBit(modified, {{ table.name }}::{{ field.name | pascalcase }});
    _builder.clear_{{field.name}}();
    return std::move(*this);
  }
  {% endfor %}

  gendb::MessagePatch Build() && {
    gendb::MessagePatch patch;
    patch.modified = std::move(modified);
    patch.removed = std::move(removed);
    patch.buffer = _builder.Build();
    return patch;
  }

 private:
  gendb::Bitmask modified;
  gendb::Bitmask removed;
  {{table.name}}Builder _builder;
};
{% if table.namespace %}
} // namespace {{ table.namespace }}
{% endif %}
{% endfor %}
